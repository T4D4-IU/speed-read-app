/// <reference types="@sveltejs/kit" />
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />
declare const self: ServiceWorkerGlobalScope;

import { build, files, version } from '$service-worker';

const ASSETS = `cache-${version}`;

// `build` is an array of all the files generated by the bundler,
// `files` is an array of all the files in the `static` directory
const to_cache = build.concat(files);
const static_assets = new Set(to_cache);

self.addEventListener('install', (event: ExtendableEvent) => {
	event.waitUntil(
		caches
			.open(ASSETS)
			.then((cache) => cache.addAll(to_cache))
			.then(() => {
				self.skipWaiting();
			})
	);
});

self.addEventListener('activate', (event: ExtendableEvent) => {
	event.waitUntil(
		caches.keys().then(async (keys) => {
			// delete old caches
			for (const key of keys) {
				if (key !== ASSETS) {
					await caches.delete(key);
				}
			}
			self.clients.claim();
		})
	);
});

self.addEventListener('fetch', (event: FetchEvent) => {
	if (event.request.method !== 'GET' || event.request.headers.has('range')) return;

	const url = new URL(event.request.url);

	// don't cache HTTP requests to other origins
	if (!url.protocol.startsWith('http')) return;

	// don't cache requests to the API
	if (url.hostname === 'api.example.com') return;

	// don't cache requests that are not `GET`
	if (event.request.method !== 'GET') return;

	// don't cache requests to the backend
	if (url.origin === self.location.origin && url.pathname.startsWith('/extract-text')) return;
	if (url.origin === self.location.origin && url.pathname.startsWith('/tokenize')) return;

	const is_asset = static_assets.has(url.pathname);

	if (is_asset) {
		event.respondWith(
			caches.match(event.request).then((cachedResponse) => {
				if (cachedResponse) {
					return cachedResponse;
				}
				// If not in cache, fetch from network
				return fetch(event.request);
			})
		);
	} else {
			event.respondWith(
				caches
					.open(ASSETS)
					.then(async (cache) => {
						try {
							const response = await fetch(event.request);
							cache.put(event.request, response.clone());
							return response;
						} catch (err) {
							return cache.match(event.request).then((cachedResponse) => {
								// If network fails, return cached response if available
								return cachedResponse || new Response('Network error', { status: 503 });
							});
						}
					})
			);
	}
});